---
pubDatetime: 2025-04-28T15:57:52.737Z
modDatetime: 2025-04-28T15:57:52.737Z

title: Object Relationships & Inheritance (OOP)
metadata_title: Object Relationships and Inheritance (OOP) - C++ Programming | V.Vidhya
slug: object-relationships-and-inheritance
featured: false
# ogImage: https://user-images.githubusercontent.com/53733092/215771435-25408246-2309-4f8b-a781-1f3d93bdf0ec.png
description: Learn Object Relationships and Inheritance (OOP) in C++ Programming by practicing exercises based on real-world scenarios with V.Vidhya.

order: 170
---

import LinkMd from '@/components/LinkMd.astro';
import CollapsibleSection from '@/components/CollapsibleSection.astro';
import Admonition from '@/components/Admonition.astro';

#### Q1.

- Create a Fruit base class that contains two private members: a name (`std::string`), and a color (`std::string`). 
- Create an Apple class that inherits Fruit. Apple should have an additional private member: fiber (`double`). 
- Create a Banana class that also inherits Fruit. Banana has no additional members.

The following program should run:

```cpp
#include <iostream>

int main()
{
	Apple a{ "Red delicious", "red", 4.2 };
	std::cout << a.printDetails() << '\n';

	Banana b{ "Cavendish", "yellow" };
	std::cout << b.printDetails() << '\n';

	return 0;
}
```

And print the following:

```ansi
Apple(Red delicious, red, 4.2)
Banana(Cavendish, yellow)
```

---

#### Q2.

- Create a Carriage class that contains three private members: an id (`int`), a type (`std::string`) and a seatCount (`int`).
- Create a Train class that contains two private members: a name (`std::string`) and carriages (`std::vector<Carriage>`) should have:
    - a constructor taking the train name,
    - an `addCarriage(`const std::string& type, int seats)` method that automatically assigns `id = carriages.size() + 1` and adds a new Carriage,
    - a `printManifest()` method that returns a `std::string` listing the train name and each carriage's specs.

And print the following:

```ansi
Train: Rajdhani Express
Carriage[1: Sleeper, 40 seats]
Carriage[2: Seater, 72 seats]
Carriage[3: Dining, 20 seats]
```

---

#### Q3.

Analyze the given programs below, predict their outputs and determine whether they follow the principles of object-oriented programming correctly.

- #### I.
    ```cpp
    #include <iostream>

    class Vehicle
    {
    private:
        int no_of_wheels;
        int engine_power;
        int seating_capacity;

    public:
        Vehicle(int wheels, int power, int capacity)
            : no_of_wheels(wheels), engine_power(power), seating_capacity(capacity) {}

        void displayInfo()
        {
            std::cout << "Number of wheels: " << no_of_wheels << '\n';
            std::cout << "Engine power: " << engine_power << " HP" << '\n';
            std::cout << "Seating capacity: " << seating_capacity << '\n';
        }

        int getSeatingCapacity()
        {
            return seating_capacity;
        }
    };

    class Car
    {
    private:
        int no_of_wheels;
        int engine_power;
        int seating_capacity;
        int no_of_doors;
        int storage_capacity;

    public:
        Car(int wheels, int power, int capacity, int doors, int storage)
            : no_of_wheels(wheels), engine_power(power), seating_capacity(capacity), no_of_doors(doors), storage_capacity(storage) {}

        void displayInfo()
        {
            std::cout << "Number of wheels: " << no_of_wheels << '\n';
            std::cout << "Engine power: " << engine_power << " HP" << '\n';
            std::cout << "Seating capacity: " << seating_capacity << '\n';
            std::cout << "Number of doors: " << no_of_doors << '\n';
            std::cout << "Storage capacity: " << storage_capacity << " liters" << '\n';
        }

        int getSeatingCapacity()
        {
            return seating_capacity;
        }
    };

    class Bike
    {
    private:
        int no_of_wheels;
        int engine_power;
        int seating_capacity;
        bool has_sidecar;

    public:
        Bike(int wheels, int power, int capacity, bool sidecar)
            : no_of_wheels(wheels), engine_power(power), seating_capacity(capacity), has_sidecar(sidecar) {}

        void displayInfo()
        {
            std::cout << "Number of wheels: " << no_of_wheels << '\n';
            std::cout << "Engine power: " << engine_power << " HP" << '\n';
            std::cout << "Seating capacity: " << seating_capacity << '\n';
            std::cout << "Has sidecar: " << (has_sidecar ? "Yes" : "No") << '\n';
        }

        int getSeatingCapacity()
        {
            return seating_capacity;
        }
    };

    int main()
    {
        Vehicle vehicle(3, 150, 3);
        std::cout << "# Vehicle Details #\n";
        vehicle.displayInfo();
        
        Car car(4, 200, 5, 4, 500);
        std::cout << "\n# Car Details #\n";
        car.displayInfo();

        Bike bike(2, 100, 2, false);
        std::cout << "\n# Bike Details #\n";
        bike.displayInfo();

        return 0;
    }
    ```

- #### II.
    ```cpp
    #include <iostream>

    class Department
    {
    private:
        std::string m_branch_name{};

    public:
        Department(std::string name)
            : m_branch_name{name}
        {
        }

        const std::string& getName() const { return m_branch_name; }
    };

    class Teacher : public Department
    {
    private:
        std::string m_teacher_name{};
        int m_salary{};

    public:
        Teacher(std::string d_name, std::string t_name, int salary)
            : Department{d_name}, m_teacher_name{t_name}, m_salary{salary}
        {
        }

        const std::string& getName() const { return m_teacher_name; }
    };

    int main()
    {
        Department department{"Computer Science"};
        Teacher teacher{"Physics", "Richard Feynman", 100000};

        std::cout << "Department name: " << department.getName() << '\n';
        std::cout << "Teacher name: " << teacher.getName() << '\n';
    
        return 0;
    }
    ```

- #### III.
    ```cpp
    #include <iostream>

    class Vehicle
    {
    private:
        int no_of_wheels;
        int engine_power;
        int seating_capacity;

    public:
        Vehicle(int wheels, int power, int capacity)
            : no_of_wheels(wheels), engine_power(power), seating_capacity(capacity) {}

        void displayInfo()
        {
            std::cout << "Number of wheels: " << no_of_wheels << '\n';
            std::cout << "Engine power: " << engine_power << " HP" << '\n';
            std::cout << "Seating capacity: " << seating_capacity << '\n';
        }

        int getSeatingCapacity()
        {
            return seating_capacity;
        }
    };

    class Car
    {
    private:
        Vehicle car_vehicle;
        int no_of_doors;
        int storage_capacity;

    public:
        Car (int wheels, int power, int capacity, int doors, int storage)
            : car_vehicle(wheels, power, capacity), no_of_doors(doors), storage_capacity(storage)
        {
        }

        void displayInfo()
        {
            car_vehicle.displayInfo();

            std::cout << "Number of doors: " << no_of_doors << '\n';
            std::cout << "Storage capacity: " << storage_capacity << " liters" << '\n';
        }

        int getSeatingCapacity()
        {
            return car_vehicle.getSeatingCapacity();
        }
    };

    class Bike
    {
    private:
        Vehicle bike_vehicle;
        bool has_sidecar;

    public:
        Bike(int wheels, int power, int capacity, bool sidecar)
            : bike_vehicle(wheels, power, capacity), has_sidecar(sidecar)
        {
        }   

        void displayInfo()
        {
            bike_vehicle.displayInfo();

            std::cout << "Has sidecar: " << (has_sidecar ? "Yes" : "No") << '\n';
        }

        int getSeatingCapacity()
        {
            return bike_vehicle.getSeatingCapacity();
        }
    };

    int main()
    {
        Vehicle vehicle(3, 150, 3);
        std::cout << "# Vehicle Details #\n";
        vehicle.displayInfo();
        
        Car car(4, 200, 5, 4, 500);
        std::cout << "\n# Car Details #\n";
        car.displayInfo();

        Bike bike(2, 100, 2, false);
        std::cout << "\n# Bike Details #\n";
        bike.displayInfo();

        return 0;
    }
    ```

---

#### Q4.

What will be the output of the following programs?

<Admonition variant="caution" title="caution">
    You have to predict the output yourself without running/executing the code.
</Admonition>

- #### I.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        Base()
        {
            std::cout << "Constructing Base\n";
        }
    };

    class Derived : public Base
    {
    public:
        Derived()
        {
            std::cout << "Constructing Derived\n";
        }
    };

    int main()
    {
        std::cout << "Instantiating Base\n";
        Base base;

        std::cout << "Instantiating Derived\n";
        Derived derived;

        return 0;
    }
    ```

- #### II.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        int m_id{};

        Base(int id = 0)
            : m_id{ id }
        {
        }

        int getId() const { return m_id; }
    };

    class Derived : public Base
    {
    public:
        double m_cost{};

        Derived(double cost = 0.0, int id = 0)
            : m_cost{ cost }, m_id{ id }
        {
        }

        double getCost() const { return m_cost; }
    };

    int main()
    {
        Base base{5};
        Derived derived{1.3, 10};

        std::cout << "base.m_id: " << base.getId() << '\n';
        std::cout << "derived.m_id: " << derived.getId() << '\n';
        std::cout << "derived.m_cost: " << derived.getCost() << '\n';

        return 0;
    }
    ```

- #### III.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        int m_id{};

        Base(int id = 0)
            : m_id{id}
        {
        }

        int getId() const { return m_id; }
    };

    class Derived : public Base
    {
    public:
        double m_cost{};

        Derived(double cost = 0.0, int id = 0)
            : m_cost{cost}
        {
            m_id = id;
        }

        double getCost() const { return m_cost; }
    };

    int main()
    {
        Base base{5};
        Derived derived{1.3, 10};

        std::cout << "base.m_id: " << base.getId() << '\n';
        std::cout << "derived.m_id: " << derived.getId() << '\n';
        std::cout << "derived.m_cost: " << derived.getCost() << '\n';

        return 0;
    }
    ```

- #### IV.
    ```cpp
    #include <iostream>

    class Base
    {
    private:
        int m_id{};

    public:

        Base(int id = 0)
            : m_id{id}
        {
        }

        int getId() const { return m_id; }
    };

    class Derived : public Base
    {
    private:
        double m_cost{};

    public:

        Derived(double cost = 0.0, int id = 0)
            : m_cost{cost}
        {
            m_id = id;
        }

        double getCost() const { return m_cost; }
    };

    int main()
    {
        Base base{5};
        Derived derived{1.3, 10};

        std::cout << "base.m_id: " << base.getId() << '\n';
        std::cout << "derived.m_id: " << derived.getId() << '\n';
        std::cout << "derived.m_cost: " << derived.getCost() << '\n';

        return 0;
    }
    ```

- #### V.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        const int m_id{};

        Base(int id = 0)
            : m_id{id}
        {
        }

        int getId() const { return m_id; }
    };

    class Derived : public Base
    {
    public:
        double m_cost{};

        Derived(double cost = 0.0, int id = 0)
            : m_cost{cost}
        {
            m_id = id;
        }

        double getCost() const { return m_cost; }
    };

    int main()
    {
        Base base{5};
        Derived derived{1.3, 10};

        std::cout << "base.m_id: " << base.getId() << '\n';
        std::cout << "derived.m_id: " << derived.getId() << '\n';
        std::cout << "derived.m_cost: " << derived.getCost() << '\n';

        return 0;
    }
    ```

- #### VI.
    ```cpp
    #include <iostream>

    class A
    {
    public:
        A()
        {
            std::cout << "Constructing A\n";
        }
    };

    class B : public A
    {
    public:
        B()
        {
            std::cout << "Constructing B\n";
        }
    };

    class C : public B
    {
    public:
        C()
        {
            std::cout << "Constructing C\n";
        }
    };

    class D : public C
    {
    public:
        D()
        {
            std::cout << "Constructing D\n";
        }
    };

    int main()
    {
        std::cout << "Instantiating A: \n";
        A a;

        std::cout << "\nInstantiating B: \n";
        B b;

        std::cout << "\nInstantiating C: \n";
        C c;

        std::cout << "\nInstantiating D: \n";
        D d;
    }
    ```

---

#### Q5.

A zoo wants to keep a registry of animals, organizing shared and unique information.

Create a program that:
- Stores common animal attributes: name, species, and age.
- For mammals, stores fur color and whether the animal is endangered.
- For birds, stores wing span (in cm) and whether the bird can fly.
- Allows displaying full details for any animal.

<CollapsibleSection title="Instructions">
- Create a base class `Animal` to store:
    - Name (e.g. ‚ÄúSher Khan‚Äù)
    - Species (e.g. ‚ÄúBengal Tiger‚Äù)
    - Age (e.g. 4)
    - Member functions to:
        - Display common media details.
- Create a derived class `Mammal` that inherits from Animal and adds:
    - Fur Color (e.g. ‚ÄúOrange with Black Stripes‚Äù)
    - Is Endangered? (e.g. true/false)
    - Member functions to:
        - Display all common details plus additional details - fur color and endangered status.
- Create another derived class `Bird` that inherits from `Animal` and adds:
    - Wing Span (in cm, e.g. 120)
    - Can Fly? (e.g. true/false)
    - Member functions to:
        - Display all common details plus additional details - wing span and flight capability.
- In `main()`, demonstrate:
    - Creating one `Mammal` object (e.g. a tiger) and one `Bird` object (e.g. a penguin).
    - Setting all relevant details.
    - Displaying each animal's full details.
</CollapsibleSection>

<div class="w-full my-2"></div>

<CollapsibleSection title="Expected Output">
```ansi
[2;3m// Mammal details:[0m
Animal Details (Mammal):
Name: Sher Khan
Species: Bengal Tiger
Age: 4
Fur Color: Orange with Black Stripes
Endangered: Yes

[2;3m// Bird details:[0m
Animal Details (Bird):
Name: Pingi
Species: Emperor Penguin
Age: 2
Wing Span: 120 cm
Can Fly: No
```
</CollapsibleSection>

---

#### Q6.

What will be the output of the following programs?

<Admonition variant="caution" title="caution">
    You have to predict the output yourself without running/executing the code.
</Admonition>

- #### I.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        int m_id{};

        Base(int id)
            : m_id{id}
        {
        }

        int getId() const { return m_id; }
    };

    class Derived : public Base
    {
    public:
        double m_cost{};

        Derived(double cost = 0.0, int id = 0)
        : m_cost{ cost }
        {
            m_id = id;
        }

        double getCost() const { return m_cost; }
    };


    int main()
    {
        Base base{5};
        Derived derived{1.3, 10};

        std::cout << "base.m_id: " << base.getId() << '\n';
        std::cout << "derived.m_id: " << derived.getId() << '\n';
        std::cout << "derived.m_cost: " << derived.getCost() << '\n';

        return 0;
    }
    ```

- #### II.
    ```cpp
    #include <iostream>

    class Base
    {
    private:
        int m_id{};

    public:
        Base(int id = 0)
            : m_id{id}
        {
        }

        int getId() const { return m_id; }
    };

    class Derived : public Base
    {
    public:
        double m_cost{};

        Derived(double cost = 0.0, int id = 0)
            : Base {id}, m_cost{cost}
        {
        }

        double getCost() const { return m_cost; }
    };

    int main()
    {
        Base base{5};
        Derived derived{1.3, 10};

        std::cout << "base.m_id: " << base.getId() << '\n';
        std::cout << "derived.m_id: " << derived.getId() << '\n';
        std::cout << "derived.m_cost: " << derived.getCost() << '\n';

        return 0;
    }
    ```

- #### III.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        int m_public {};
    protected:
        int m_protected {};
    private:
        int m_private {};
    };

    class Pub: public Base 
    {
    public:
        Pub()
        {
            m_public = 1;
            m_protected = 2;
            m_private = 3;
        }
    };

    int main()
    {
        Base base;
        base.m_public = 1;
        base.m_protected = 2;
        base.m_private = 3;

        Pub pub;
        pub.m_public = 1;
        pub.m_protected = 2;
        pub.m_private = 3;

        return 0;
    }
    ```

- #### IV.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        int m_public {};
    protected:
        int m_protected {};
    private:
        int m_private {};
    };

    class Pri: private Base
    {
    public:
        Pri()
        {
            m_public = 1;
            m_protected = 2;
            m_private = 3;
        }
    };

    int main()
    {
        Base base;
        base.m_public = 1;
        base.m_protected = 2;
        base.m_private = 3;

        Pri pri;
        pri.m_public = 1;
        pri.m_protected = 2;
        pri.m_private = 3;

        return 0;
    }
    ```

- #### V.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        Base()
        {
            std::cout << "Base()\n";
        }
        ~Base()
        {
            std::cout << "~Base()\n";
        }
    };

    class Derived: public Base
    {
    public:
        Derived()
        {
            std::cout << "Derived()\n";
        }
        ~Derived()
        {
            std::cout << "~Derived()\n";
        }
    };

    int main()
    {
        Base b;
        Derived d;

        return 0;
    }
    ```

---

#### Q7.

A computer shop needs a simple tool to keep track of each machine and its parts.

Create a program that:
- Keeps common computer info: brand and model name.
- For the CPU processor, stores number of cores and clock speed in GHz.
- For memory, lets you add multiple modules, each with a size in GB and a type chosen from a fixed list (for e.g. ‚ÄúDDR3‚Äù, ‚ÄúDDR4‚Äù, ‚ÄúDDR5‚Äù).
- Can show all the details of a computer in one formatted display.

<CollapsibleSection title="Instructions">
In your design you should:
- Have a Computer class that holds its brand, model, one CPU and a list of MemoryModules.
- Have a CPU class that stores its core count and clock speed.
- Have a MemoryModule class that stores its capacity and a type chosen from a predefined set of memory types (use an enum for the types).
- Let Computer provide a way to add memory modules.
- Provide a way to print everything: the computer's brand and model, the CPU's specs and each memory module's size and type.
- In `main()`, demonstrate by:
    - Creating a computer (pick any brand and model).
    - Adding at least two memory modules of different sizes/types.
    - Printing the computer's full details.
</CollapsibleSection>

<CollapsibleSection title="Expected Output">
```ansi
Computer: ThinkPad X1 Carbon
CPU: 6 cores @ 2.8 GHz
Memory Modules:
  - 16 GB DDR4
  - 32 GB DDR5
```
</CollapsibleSection>

---

#### Q8.

- #### I.

Write an Apple class and a Banana class that are derived from a common Fruit class. Fruit should have two members: a name and a color.

The following program should run:

```cpp
int main()
{
	Apple a{ "red" };
	Banana b{};

	std::cout << "My " << a.getName() << " is " << a.getColor() << ".\n";
	std::cout << "My " << b.getName() << " is " << b.getColor() << ".\n";

	return 0;
}
```

And produce the result:

```ansi
My apple is red.
My banana is yellow.
```

- #### II.

Add a new class to the previous program called GrannySmith that inherits from Apple.

The following program should run:

```cpp
int main()
{
	Apple a{ "red" };
	Banana b;
	GrannySmith c;

	std::cout << "My " << a.getName() << " is " << a.getColor() << ".\n";
	std::cout << "My " << b.getName() << " is " << b.getColor() << ".\n";
	std::cout << "My " << c.getName() << " is " << c.getColor() << ".\n";

	return 0;
}
```

And produce the result:

```ansi
My apple is red.
My banana is yellow.
My Granny Smith apple is green.
```

---

#### Q9.

What will be the output of the following programs?

<Admonition variant="caution" title="caution">
    You have to predict the output yourself without running/executing the code.
</Admonition>

- #### I.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        Base() { }

        void identify() const { std::cout << "Base::identify()\n"; }
    };

    class Derived: public Base
    {
    public:
        Derived() { }
    };

    int main()
    {
        Base base {};
        base.identify();

        Derived derived {};
        derived.identify();

        return 0;
    }
    ```

- #### II.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        Base() { }

        void identify() const { std::cout << "Base::identify()\n"; }
    };

    class Derived: public Base
    {
    public:
        Derived() { }

        void identify() const { std::cout << "Derived::identify()\n"; }
    };

    int main()
    {
        Base base {};
        base.identify();

        Derived derived {};
        derived.identify();

        return 0;
    }
    ```

- #### III.
    ```cpp
    #include <iostream>

    class Base
    {
    private:
        void print() const
        {
            std::cout << "Base";
        }
    };

    class Derived : public Base
    {
    public:
        void print() const
        {
            std::cout << "Derived ";
        }
    };


    int main()
    {
        Base base {};
        base.print();
        
        Derived derived {};
        derived.print();

        return 0;
    }
    ```

- #### IV.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        Base() { }

        void identify() const { std::cout << "Base::identify()\n"; }
    };

    class Derived: public Base
    {
    public:
        Derived() { }

        void identify() const
        {
            std::cout << "Derived::identify()\n";
            Base::identify();
        }
    };

    int main()
    {
        Base base {};
        base.identify();

        Derived derived {};
        derived.identify();

        return 0;
    }
    ```

- #### V.
    ```cpp
    #include <iostream>

    class Base
    {
    public:
        Base() {}

        void identify() const { std::cout << "Base::identify()\n"; }
    };

    class Derived : public Base
    {
    public:
        Derived() {}

        void identify() const
        {
            std::cout << "Derived::identify()\n";
            identify();
        }
    };

    int main()
    {
        Base base{};
        base.identify();

        Derived derived{};
        derived.identify();

        return 0;
    }
    ```

---

#### Q10.

An e-learning platform wants to manage different types of courses (SelfPaced and LiveSession) using shared and unique information. 
Each course must enforce invariants (no negative prices or durations) and support behaviors like enrolling students, tracking progress, or 
scheduling sessions.

Create a program that:
- Stores common course attributes: course title, course ID and price.
- For self-paced courses, stores total video hours and number of modules, and provides functions to mark modules complete and calculate percentage progress.
- For live session courses, stores a scheduled date, maximum class size, and number of enrolled students, and provides functions to enroll a student 
(updating count until max) and check if the course is full.
- Enforces invariants: any negative price, video hours, modules, class size or enrolled count become zero; if enrolled count exceeds max, clamp to max.
- Allows displaying full details for any course, as well as calling its specific behaviors.

<CollapsibleSection title="Instructions">
- Create a base class `Course` to store:
    - Course Title (e.g. ‚ÄúIntro to C++‚Äù)
    - Course ID (e.g. ‚ÄúCSE101‚Äù)
    - Price (in ruppees, e.g. 15000.00)
    - Member functions to:
        - Display common course details.
- Create a derived class `SelfPacedCourse` that inherits from Course and adds:
    - Total Video Hours (e.g. 10.5)
    - Number of Modules (e.g. 8)
    - Completed Modules (initially 0)
    - Member functions to:
        - Mark a module as completed, which increments the completed modules count, up to the total number of modules.
        - To know the progress percentage.
        - Display all the course details.
    - Getter and Setter functions for Total Video Hours and Number of Modules.
- Create a derived class `LiveSessionCourse` that inherits from Course and adds:
    - Course Duration (in months, e.g. 3)
    - Max Class Size (e.g. 30)
    - Enrolled Students (initially 0)
    - Member functions to:
        - Enroll a student, which increments the enrolled students count, up to the max class size.
        - To check if the class is full.
        - Display all the course details.
    - Getter and Setter functions for Course Duration.
- In `main()`, demonstrate:
    - Creating one `SelfPacedCourse` object, setting valid relevant details.
    - Display all the course details for it.
    - For `SelfPacedCourse` object, call complete module function several times and print the progress percent after each to show how progress increases.
    - Use the relevant access function to change the video hours of one course, then display the course details again to confirm the update.
    - Attempt to call complete module function enough times to exceed the total number of modules, and show that completed modules count 
    never goes past its maximum.
    - Creating one `LiveSessionCourse` object, setting valid relevant details.
    - Display all the course details for it.
    - For `LiveSessionCourse` object, repeatedly call enroll student function, until the class is full and then attempt to enroll one more student
    to verify that enrollment is blocked when at capacity.
    - Finally, create one `SelfPacedCourse` and one `LiveSessionCourse` each with invalid inputs 
    (e.g., empty title or ID, negative price, negative video hours, negative modules, negative class size, or enrolled > max).
    - Displaying each course's full details.
    - Display all the course details for each to show how invalid values were replaced by defaults, verifying that class invariants work as intended.
</CollapsibleSection>

<div class="w-full my-2"></div>

<CollapsibleSection title="Expected Output">
```ansi
[2;3m// Self-Paced Course 1 details:[0m
Course Details (SelfPaced):
Course: C++ Basics
ID: C101
Price: rs.25000.00
Video Hours: 30.50
Modules: 0 / 5 (0.00%)

[2;3m// Completing modules for C++ Basics...[0m
Completed module 1. Progress: 20.00%
Completed module 2. Progress: 40.00%
Completed module 3. Progress: 60.00%

[2;3m// Updating video hours for C++ Basics to 36.00...[0m
Course Details (SelfPaced):
Course: C++ Basics
ID: C101
Price: rs.25000.00
Video Hours: 36.00
Modules: 3 / 5 (60.00%)

[2;3m// Completing remaining modules...[0m
Completed module 4. Progress: 80.00%
Completed module 5. Progress: 100.00%
[2;3m// Attempting extra module completion...[0m
Modules: 5 / 5 (100.00%)


[2;3m// Live Session Course 1 details:[0m
Course Details (LiveSession):
Course: Graphics Design
ID: GD301
Price: rs.40000.00
Course Duration: 8 months
Class Size: 1 / 3 (Open)

[2;3m// Enrolling student for Data Structures Live...[0m
Enrollment successful.
Course Details (LiveSession):
Course: Graphics Design
ID: GD301
Price: rs.40000.00
Course Duration: 8 months
Class Size: 2 / 3 (Open)

[2;3m// Enrolling one more student for Data Structures Live...[0m
Enrollment successful.
Course Details (LiveSession):
Course: Graphics Design
ID: GD301
Price: rs.40000.00
Course Duration: 8 months
Class Size: 3 / 3 (Full)

[2;3m// Attempting one more enrollment...[0m
Enrollment failed. Class is full.

[2;3m// Invalid Self-Paced Course details:[0m
Course Details (SelfPaced):
Course: UNKNOWN
ID: UNKNOWN
Price: rs.0.00
Video Hours: 0.00
Modules: 0 / 0 (0.00%)

[2;3m// Invalid Live Session Course details:[0m
Course Details (LiveSession):
Course: UNKNOWN
ID: UNKNOWN
Price: rs.0.00
Scheduled Date: 
Class Size: 0 / 0 (Full)
```
</CollapsibleSection>

---

#### Q11. **_(Adv.)_**

An online marketplace sells a wide variety of items, from physical goods to digital downloads. Each product shares some common information, 
but extends into different details and behaviors depending on its type. So the store manager needs a tool that helps him maintain a unified 
catalog of all products, check whether an item can be sold (based on stock or valid license) and process orders accordingly.

<CollapsibleSection title="Instructions">
- **Catalog Management**
    - Your program should allow the manager to add new products to the catalog, specifying:
        - Common fields:
            - product ID (e.g. "P1001" or "D2001")
            - product name (e.g. "Wireless Mouse" or "C++ eBook")
            - unit price (e.g. 25.00)
        - If it's a physical good: 
            - shipping weight in kg (e.g. 0.2)
            - dimensions (length x width x height in cm, e.g. 10 x 5 x 3)
            - initial stock count (e.g. 50)
        - If it's a digital download: 
            - file size in MB (e.g. 5)
            - full download URL (e.g. "example.com/download/ebook") 
            - license validity date (in dd/mm/yyyy format, e.g. 31-12-2025)
    - After adding items, the manager can ask the program to display all products, which prints every product's full information.
- **Availability Checking & Ordering**
    - When a customer tries to order some quantity of a product (physical or digital), the program must:
        - Look up the product by ID.
        - If it's a physical good:
            - Verify that the requested quantity is not more than the current stock.
            - If not enough stock, print an "Out of stock" or "Insufficient stock" message and decline the order.
            - If enough stock, calculate `shipping cost = (weight x shipping - rate) x quantity`. Use a fixed shipping rate of rs.5 per kg.
            - Reduce the product's stock by the purchased quantity.
            - Print an order summary showing product name, quantity, unit price, shipping cost (breakdown per unit and total), total cost and the 
            updated stock remaining.
        - If it's a digital download:
            - Check today's date (for e.g. assume the system date is "02-06-2025") against the license validity date.
            - If today is after the license expiry date, decline the order with "License expired" or "Download not available."
            - If the license is still valid, do not change any stock (digital items do not run out), but print an order summary showing product name, 
            quantity, unit price, total cost and the download URL.
- **User Interaction Workflow**
    - Add at least one physical product and one digital product to your catalog.
    - Display all products once after adding them.
    - Attempt these orders in sequence:
        - Order 2 units of the physical product.
        - Order 1 copy of the digital product.
        - Attempt to order more units of the physical product than remain in stock (to show the "insufficient stock" message).
        - Attempt to order the digital product again after the license has expired (to show the "License expired" message).
    - After each attempt, print the program's response or order summary.
    - At the very end, display all products again so the manager sees updated stock for the physical good.
</CollapsibleSection>

<div class="w-full my-2"></div>

<CollapsibleSection title="Expected Output">
```ansi
All Products:
-------------------------------
Product ID: P1001
Name: Wireless Mouse
Price: rs.500.00
Type: Physical
Weight: 0.225 kg
Dimensions: 10 x 5 x 3 cm
Stock: 50

Product ID: D2001
Name: C++ eBook
Price: rs.750.00
Type: Digital
File Size: 5.00 MB
Download Link: www.example.com/download/cppebook
License Valid Until: 31/12/2025

Ordering 2 x P1001 (Wireless Mouse)...
Availability check passed (stock 50 ‚â• 2).
Shipping rate: rs.5.00 per kg
Weight per unit: 0.20 kg
Shipping per unit: 0.20 x rs.5.00 = rs.1.00
Total shipping for 2 units: rs.2.00

Order Summary (Physical Product):
---------------------------------
Product: Wireless Mouse
Quantity: 2
Unit Price: rs.500.00
Subtotal (price x quantity): rs.1000.00
Shipping Cost: rs.2.00
Total Cost: rs.1002.00
Remaining Stock for P1001: 48
---------------------------------

Ordering 1 x D2001 (C++ eBook)...
Current Date: 02/06/2025
License Valid Until: 31/12/2025
License is valid. Proceeding with download.

Order Summary (Digital Product):
---------------------------------
Product: C++ eBook
Quantity: 1
Unit Price: rs.750.00
Subtotal (price x quantity): rs.750.00
Download Link: www.example.com/download/cppebook
---------------------------------

Ordering 100 x P1001 (Wireless Mouse)...
Availability check failed. Requested: 100, In Stock: 48.
Insufficient stock! Order cannot be processed.

Ordering 1 x D2001 (C++ eBook)...
Current Date: 15/01/2026
License Valid Until: 31/12/2025
License expired! Download not available. Order declined.

All Products:
-------------------------------
Product ID: P1001
Name: Wireless Mouse
Price: rs.500.00
Type: Physical
Weight: 0.20 kg
Dimensions: 10 x 5 x 3 cm
Stock: 48

Product ID: D2001
Name: C++ eBook
Price: rs.750.00
Type: Digital
File Size: 5.00 MB
Download Link: www.example.com/download/cppebook
License Valid Until: 31/12/2025
```
</CollapsibleSection>